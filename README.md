   ## Домашнее задание к занятию 4 «Оркестрация группой Docker контейнеров на примере Docker Compose».

## Михеев Алексей 


### Задача 1

Сценарий выполнения задачи:

1. Установите docker и docker compose plugin на свою linux рабочую станцию или ВМ.
   
2. Если dockerhub недоступен создайте файл /etc/docker/daemon.json с содержимым: {"registry-mirrors": ["https://mirror.gcr.io", "https://daocloud.io", "https://c.163.com/", "https://registry.docker-cn.com"]}

3. Зарегистрируйтесь и создайте публичный репозиторий с именем "custom-nginx" на https://hub.docker.com (ТОЛЬКО ЕСЛИ У ВАС ЕСТЬ ДОСТУП);

4. Cкачайте образ nginx:1.21.1;

5. Создайте Dockerfile и реализуйте в нем замену дефолтной индекс-страницы(/usr/share/nginx/html/index.html), на файл index.html с содержимым:

         <html>
   
         <head>

         Hey, Netology

         </head>

         <body>

         <h1>I will be DevOps Engineer!</h1>

         </body>

         </html>

7. Соберите и отправьте созданный образ в свой dockerhub-репозитории c tag 1.0.0 (ТОЛЬКО ЕСЛИ ЕСТЬ ДОСТУП).

8. Предоставьте ответ в виде ссылки на https://hub.docker.com/<username_repo>/custom-nginx/general .

### Ответ:

https://hub.docker.com/repository/docker/alm7988/custom-nginx/tags/1.0.0



### Задача 2

1. Запустите ваш образ custom-nginx:1.0.0 командой docker run в соответвии с требованиями:
   
- имя контейнера "ФИО-custom-nginx-t2"

- контейнер работает в фоне

- контейнер опубликован на порту хост системы 127.0.0.1:8080

2. Не удаляя, переименуйте контейнер в "custom-nginx-t2"

3. Выполните команду date +"%d-%m-%Y %T.%N %Z" ; sleep 0.150 ; docker ps ; ss -tlpn | grep 127.0.0.1:8080  ; docker logs custom-nginx-t2 -n1 ; docker exec -it custom-nginx-t2 base64 /usr/share/nginx/html/index.html

4. Убедитесь с помощью curl или веб браузера, что индекс-страница доступна.

В качестве ответа приложите скриншоты консоли, где видно все введенные команды и их вывод.

### Ответ:

![1](https://github.com/Alm798/docker-intro/blob/main/2.1.png)

![2](https://github.com/Alm798/docker-intro/blob/main/2.2.png)


### Задача 3

1. Воспользуйтесь docker help или google, чтобы узнать как подключиться к стандартному потоку ввода/вывода/ошибок контейнера "custom-nginx-t2".

2. Подключитесь к контейнеру и нажмите комбинацию Ctrl-C.

3. Выполните docker ps -a и объясните своими словами почему контейнер остановился.

Ответ:

После выполнения команды docker attach я был подключён напрямую к стандартному вводу и выводу основного процесса контейнера — nginx, который запущен в foreground. Нажатие Ctrl-C отправляет процессу сигнал SIGINT, что приводит к завершению основного процесса. Поскольку в контейнере главный процесс завершился, Docker считает контейнер остановленным. Поэтому после Ctrl-C контейнер перешёл в состояние Exited.

4. Перезапустите контейнер

5. Зайдите в интерактивный терминал контейнера "custom-nginx-t2" с оболочкой bash.

6. Установите любимый текстовый редактор(vim, nano итд) с помощью apt-get.

7. Отредактируйте файл "/etc/nginx/conf.d/default.conf", заменив порт "listen 80" на "listen 81".

8. Запомните(!) и выполните команду nginx -s reload, а затем внутри контейнера curl http://127.0.0.1:80 ; curl http://127.0.0.1:81.

9. Выйдите из контейнера, набрав в консоли exit или Ctrl-D.

10. Проверьте вывод команд: ss -tlpn | grep 127.0.0.1:8080 , docker port custom-nginx-t2, curl http://127.0.0.1:8080. Кратко объясните суть возникшей проблемы.

Ответ:

В конфигурации nginx я изменил порт прослушивания с 80 на 81. Однако Docker по-прежнему пробрасывает порт 8080 хоста на порт 80 контейнера (8080 → 80). После изменения конфигурации на порту 80 внутри контейнера ничего не слушает. Поэтому при запросе http://127.0.0.1:8080 соединение на хосте устанавливается, но внутри контейнера некому его обрабатывать, и происходит ошибка подключения.

Суть проблемы в том, что Docker-порт не меняется автоматически при изменении порта внутри контейнера — приложение и Docker-проброс должны быть согласованы вручную.

11. Это дополнительное, необязательное задание. Попробуйте самостоятельно исправить конфигурацию контейнера, используя доступные источники в интернете. Не изменяйте конфигурацию nginx и не удаляйте контейнер. Останавливать контейнер можно. пример источника

12. Удалите запущенный контейнер "custom-nginx-t2", не останавливая его.(воспользуйтесь --help или google)

В качестве ответа приложите скриншоты консоли, где видно все введенные команды и их вывод.

### Ответ:

![3.1](https://github.com/Alm798/docker-intro/blob/main/3.1.png)

![3.2](https://github.com/Alm798/docker-intro/blob/main/3.2.png)

![3.3](https://github.com/Alm798/docker-intro/blob/main/3.3.png)



### Задача 4

1. Запустите первый контейнер из образа centos c любым тегом в фоновом режиме, подключив папку текущий рабочий каталог $(pwd) на хостовой машине в /data контейнера, используя ключ -v.

2. Запустите второй контейнер из образа debian в фоновом режиме, подключив текущий рабочий каталог $(pwd) в /data контейнера.

3. Подключитесь к первому контейнеру с помощью docker exec и создайте текстовый файл любого содержания в /data.

4. Добавьте ещё один файл в текущий каталог $(pwd) на хостовой машине.

5. Подключитесь во второй контейнер и отобразите листинг и содержание файлов в /data контейнера.

В качестве ответа приложите скриншоты консоли, где видно все введенные команды и их вывод.

### Ответ:

![4.1](https://github.com/Alm798/docker-intro/blob/main/4.1.png)

![4.2](https://github.com/Alm798/docker-intro/blob/main/4.2.png)



### Задача 5

1. Создайте отдельную директорию(например /tmp/netology/docker/task5) и 2 файла внутри него.

"compose.yaml" с содержимым:

    version: "3"

    services:

        portainer:

          network_mode: host

          image: portainer/portainer-ce:latest

          volumes:

            - /var/run/docker.sock:/var/run/docker.sock


"docker-compose.yaml" с содержимым:

      version: "3"

      services:

        registry:

          image: registry:2

          ports:
      
          - "5000:5000"

  
И выполните команду "docker compose up -d". Какой из файлов был запущен и почему? (подсказка: https://docs.docker.com/compose/compose-application-model/#the-compose-file )

Ответ:

При выполнении команды docker compose up -d Docker Compose выбирает файл конфигурации по приоритету имён. Наивысший приоритет имеет файл compose.yaml, затем compose.yml, и только потом — docker-compose.yaml.

Поскольку в каталоге присутствовали оба файла — compose.yaml и docker-compose.yaml, Compose выбрал именно compose.yaml как основной. Поэтому сначала был запущен только сервис portainer, описанный в нём, а сервис registry из docker-compose.yaml проигнорирован.

2. Отредактируйте файл compose.yaml так, чтобы были запущенны оба файла. (подсказка: https://docs.docker.com/compose/compose-file/14-include/)

3. Выполните в консоли вашей хостовой ОС необходимые команды чтобы залить образ custom-nginx как custom-nginx:latest в запущенное вами, локальное registry. Дополнительная документация: https://distribution.github.io/distribution/about/deploying/

4. Откройте страницу "https://127.0.0.1:9000" и произведите начальную настройку portainer.(логин и пароль адмнистратора)

5. Откройте страницу "http://127.0.0.1:9000/#!/home", выберите ваше local окружение. Перейдите на вкладку "stacks" и в "web editor" задеплойте следующий компоуз:

         version: '3'

         services:
 
           nginx:

             image: 127.0.0.1:5000/custom-nginx

             ports:

               - "9090:80"


      
6. Перейдите на страницу "http://127.0.0.1:9000/#!/2/docker/containers", выберите контейнер с nginx и нажмите на кнопку "inspect". В представлении <> Tree разверните поле "Config" и сделайте скриншот от поля "AppArmorProfile" до "Driver".

7. Удалите любой из манифестов компоуза(например compose.yaml). Выполните команду "docker compose up -d". Прочитайте warning, объясните суть предупреждения и выполните предложенное действие. Погасите compose-проект ОДНОЙ(обязательно!!) командой.
ОТвет :
После удаления файла compose.yaml и повторного запуска docker compose up -d Compose использовал только оставшийся файл docker-compose.yaml.

Однако контейнеры, созданные ранее из compose.yaml (например portainer), всё ещё существовали и были связаны с текущим compose-проектом, хотя в новом файле они больше не описаны.

Docker обнаружил такие контейнеры и вывел предупреждение об orphan containers — «осиротевших контейнерах».
______________________________

Команда *docker compose down* --remove-orphans завершает и удаляет все контейнеры, запущенные текущим compose-проектом, включая «осиротевшие» контейнеры, которые были созданы предыдущими версиями compose-файла и больше не описаны в актуальном compose-файле. Это полностью очищает проект, как требует задание.



Суть предупреждения:
эти контейнеры больше не управляются текущим compose-файлом и могут создавать путаницу, поэтому рекомендуется их удалить с помощью docker compose down --remove-orphans

В качестве ответа приложите скриншоты консоли, где видно все введенные команды и их вывод, файл compose.yaml , скриншот portainer c задеплоенным компоузом.

### Ответ:

![5.1](https://github.com/Alm798/docker-intro/blob/main/5.5.png)

![5.2](https://github.com/Alm798/docker-intro/blob/main/5.6.png)

![5.3](https://github.com/Alm798/docker-intro/blob/main/5.1.png)

![5.4](https://github.com/Alm798/docker-intro/blob/main/5.2.png)

![5.5](https://github.com/Alm798/docker-intro/blob/main/5.3.png)

![5.6](https://github.com/Alm798/docker-intro/blob/main/5.4.png)

